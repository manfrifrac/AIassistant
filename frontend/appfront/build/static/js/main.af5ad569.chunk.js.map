{"version":3,"sources":["components/BezierDiamond.js","components/AudioAnalyzer.js","App.js","reportWebVitals.js","index.js"],"names":["BezierDiamond","_ref","audioLevel","isActive","horizontal","Math","min","max","vertical","pathData","useMemo","concat","size","trim","React","createElement","width","height","className","viewBox","d","fill","strokeLinecap","strokeLinejoin","AudioAnalyzer","constructor","this","audioContext","window","AudioContext","webkitAudioContext","analyser","createAnalyser","fftSize","smoothingTimeConstant","dataArray","Uint8Array","frequencyBinCount","prevLevel","source","bufferSize","levelBuffer","Array","bufferIndex","interpolationFactor","peakDecay","peakLevel","error","console","connectSource","audioElement","disconnect","state","resume","createMediaElementSource","connect","destination","log","getLevel","timeDomainData","getByteTimeDomainData","sumOfSquares","i","length","sample","currentLevel","sqrt","weights","from","_","exp","weightSum","reduce","a","b","smoothedLevel","idx","t","interpolatedLevel","pow","ENDPOINTS","CHAT_STATUS","CHAT_MESSAGE","AUDIO_UPLOAD","WEBSOCKET","App","status","setStatus","useState","command","setCommand","isRecording","setIsRecording","mediaRecorderRef","useRef","audioChunksRef","isPlaying","setIsPlaying","setAudioLevel","analyserRef","animationFrameRef","audioRef","isAssistantSpeaking","setIsAssistantSpeaking","audioAnalyzer","useEffect","fetch","then","response","ok","Error","json","data","message","catch","startRecording","async","stream","navigator","mediaDevices","getUserMedia","audio","current","MediaRecorder","audioCtx","createMediaStreamSource","updateAudioLevel","getByteFrequencyData","map","value","weightedAverage","requestAnimationFrame","setupAudioAnalyser","ondataavailable","event","push","onstop","audioBlob","Blob","type","sendAudioToBackend","start","setupAssistantAudioAnalyser","audioData","Audio","addEventListener","formData","FormData","append","method","body","text","audio_response","play","e","updateLevel","paused","cancelAnimationFrame","id","onChange","target","onKeyPress","key","headers","Content-Type","JSON","stringify","user_id","uuidv4","session_id","metadata","handleSend","placeholder","onClick","handleMic","stop","getTracks","forEach","track","title","reportWebVitals","onPerfEntry","Function","__webpack_require__","bind","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.af5ad569.chunk.js","sourcesContent":["import React, { useState, useEffect, useMemo, useRef } from 'react';\r\n\r\nexport function BezierDiamond({ audioLevel, isActive }) {\r\n  const size = 300;\r\n  const centerX = size / 2;\r\n  const centerY = size / 2;\r\n  const maxWidth = 120; // Massima distanza orizzontale\r\n  const maxHeight = 60;\r\n\r\n  // Calcoliamo l’apertura orizzontale:\r\n  const horizontal = maxWidth * (1 - Math.min(Math.max(audioLevel, 0), 1));\r\n  const leftX = centerX - horizontal;\r\n  const rightX = centerX + horizontal;\r\n\r\n  // L’altezza varia inversamente con l’apertura orizzontale\r\n  const vertical = maxHeight * Math.min(Math.max(audioLevel, 0), 1);\r\n  const topY = centerY - vertical;\r\n  const bottomY = centerY + vertical;\r\n\r\n  // Aggiunta di punti di controllo extra per asintoti\r\n  const controlOffset = horizontal * 0.3;\r\n\r\n  const pathData = useMemo(() => `\r\n    M ${centerX - horizontal} ${centerY}\r\n    C ${centerX - horizontal} ${centerY - vertical},\r\n      ${centerX + horizontal} ${centerY - vertical},\r\n      ${centerX + horizontal} ${centerY}\r\n    C ${centerX + horizontal} ${centerY + vertical},\r\n      ${centerX - horizontal} ${centerY + vertical},\r\n      ${centerX - horizontal} ${centerY}\r\n    Z\r\n  `.trim(), [audioLevel]);\r\n\r\n  return (\r\n    <svg\r\n      width={size}\r\n      height={size}\r\n      className={`audio-visualizer ${isActive ? 'active' : ''}`}\r\n      viewBox={`0 0 ${size} ${size}`}\r\n    >\r\n      <path\r\n        d={pathData}\r\n        className=\"wave-path\"\r\n        fill=\"none\"\r\n        strokeLinecap=\"round\"\r\n        strokeLinejoin=\"round\"\r\n      />\r\n    </svg>\r\n  );\r\n}\r\n","export class AudioAnalyzer {\r\n  constructor() {\r\n    try {\r\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      this.analyser = this.audioContext.createAnalyser();\r\n      this.analyser.fftSize = 2048; // Modificato per ottenere un segnale grezzo nel dominio del tempo\r\n      this.analyser.smoothingTimeConstant = 0.3;\r\n      this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n      this.prevLevel = 0;\r\n      this.source = null;\r\n      \r\n      // Buffer circolare per smoothing avanzato\r\n      this.bufferSize = 12;\r\n      this.levelBuffer = new Array(this.bufferSize).fill(0);\r\n      this.bufferIndex = 0;\r\n      \r\n      // Parametri di interpolazione\r\n      this.interpolationFactor = 0.15;\r\n      this.peakDecay = 0.92;\r\n      this.peakLevel = 0;\r\n    } catch (error) {\r\n      console.error('Error initializing AudioAnalyzer:', error);\r\n    }\r\n  }\r\n\r\n  connectSource(audioElement) {\r\n    try {\r\n      if (this.source) {\r\n        this.source.disconnect();\r\n      }\r\n      \r\n      if (this.audioContext.state === 'suspended') {\r\n        this.audioContext.resume();\r\n      }\r\n      \r\n      this.source = this.audioContext.createMediaElementSource(audioElement);\r\n      this.source.connect(this.analyser);\r\n      this.analyser.connect(this.audioContext.destination);\r\n      console.log('Audio source connected successfully');\r\n    } catch (error) {\r\n      console.error('Error connecting audio source:', error);\r\n    }\r\n  }\r\n\r\n  getLevel() {\r\n    try {\r\n      const timeDomainData = new Uint8Array(this.analyser.frequencyBinCount);\r\n      this.analyser.getByteTimeDomainData(timeDomainData);\r\n\r\n      // Calcoliamo l'RMS del segnale: media quadratica\r\n      let sumOfSquares = 0;\r\n      for (let i = 0; i < timeDomainData.length; i++) {\r\n        const sample = (timeDomainData[i] - 128) / 128;\r\n        sumOfSquares += sample * sample;\r\n      }\r\n      const rms = Math.sqrt(sumOfSquares / timeDomainData.length);\r\n\r\n      let currentLevel = rms; // Valore grezzo\r\n      // Rilevamento picco e decadimento\r\n      this.peakLevel = Math.max(currentLevel, this.peakLevel * this.peakDecay);\r\n\r\n      // Buffer circolare per smoothing\r\n      this.levelBuffer[this.bufferIndex] = currentLevel;\r\n      this.bufferIndex = (this.bufferIndex + 1) % this.bufferSize;\r\n\r\n      // Media pesata con enfasi sui valori più recenti\r\n      const weights = Array.from({length: this.bufferSize}, (_, i) => Math.exp(-i * 0.2));\r\n      const weightSum = weights.reduce((a, b) => a + b);\r\n\r\n      let smoothedLevel = 0;\r\n      for (let i = 0; i < this.bufferSize; i++) {\r\n        const idx = (this.bufferIndex - i + this.bufferSize) % this.bufferSize;\r\n        smoothedLevel += this.levelBuffer[idx] * weights[i];\r\n      }\r\n      smoothedLevel /= weightSum;\r\n\r\n      // Interpolazione cubica\r\n      const t = this.interpolationFactor;\r\n      const interpolatedLevel = this.prevLevel +\r\n        (smoothedLevel - this.prevLevel) * (1 - Math.pow(1 - t, 3));\r\n\r\n      this.prevLevel = interpolatedLevel;\r\n\r\n      // Usiamo la peakLevel come base\r\n      return 2.5 * Math.pow(Math.max(interpolatedLevel, this.peakLevel * 0.8), 1.2);\r\n    } catch (error) {\r\n      console.error('Error getting audio level:', error);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { v4 as uuidv4 } from 'uuid';  // Add this import\nimport { BezierDiamond } from './components/BezierDiamond';\nimport { AudioAnalyzer } from './components/AudioAnalyzer';\nimport './App.css';\n\n// URLs e endpoints\nconst API_URL = '';\n\nconst ENDPOINTS = {\n  CHAT_STATUS: `/api/status`,\n  CHAT_MESSAGE: `/api/chat/message`,\n  AUDIO_UPLOAD: `/api/audio`,\n  WEBSOCKET: '/ws'\n};\n\nfunction App() {\n  const [status, setStatus] = useState('Idle');\n  const [command, setCommand] = useState('');\n  const [isRecording, setIsRecording] = useState(false);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [audioLevel, setAudioLevel] = useState(0);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const audioRef = useRef(null);\n  const [isAssistantSpeaking, setIsAssistantSpeaking] = useState(false);\n  const audioAnalyzer = useRef(null);\n\n  useEffect(() => {\n    // Initial connection check\n    fetch(ENDPOINTS.CHAT_STATUS)  // Verifica che sia /api/chat\n      .then(response => {\n        if (!response.ok) throw new Error('Network response was not ok');\n        return response.json();\n      })\n      .then(data => {\n        setStatus(data.message);\n        console.log('Connection status:', data);  // Updated log message\n      })\n      .catch(error => {\n        setStatus('Connection Error');\n        console.error('Error:', error);\n      });\n  }, []);\n\n  const handleSend = async () => {\n    if (!command.trim()) return;\n    \n    setStatus('Sending...');\n    try {\n      const response = await fetch(ENDPOINTS.CHAT_MESSAGE, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          message: command.trim(),\n          user_id: uuidv4(),\n          session_id: uuidv4(),\n          metadata: {}\n        })\n      });\n      \n      if (!response.ok) throw new Error('Network response was not ok');\n      \n      const data = await response.json();\n      console.log('Response received:', data);\n      setStatus(data.message);\n\n      if (data.audio_response) {  // Cambiato da data.audio a data.audio_response\n        console.log('Audio response received, attempting to play...');\n        const audioData = `data:audio/wav;base64,${data.audio_response}`;\n        const audio = setupAssistantAudioAnalyser(audioData);\n        if (audio) {\n          try {\n            await audio.play();\n            console.log('Audio playback started');\n          } catch (e) {\n            console.error('Error playing audio:', e);\n          }\n        }\n      } else {\n        console.log('No audio response in data');\n      }\n    } catch (error) {\n      setStatus('Error: ' + error.message);\n      console.error('Error:', error);\n    }\n  };\n\n  const setupAudioAnalyser = (stream) => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    const analyser = audioCtx.createAnalyser();\n    const source = audioCtx.createMediaStreamSource(stream);\n    \n    analyser.fftSize = 32;\n    source.connect(analyser);\n    analyserRef.current = analyser;\n    \n    const updateAudioLevel = () => {\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n      analyser.getByteFrequencyData(dataArray);\n      \n      // Calcola una media pesata delle frequenze\n      const weights = dataArray.map((value, i) => value * (i + 1));\n      const weightedAverage = weights.reduce((a, b) => a + b, 0) / weights.length;\n      \n      setAudioLevel(weightedAverage / 128);\n      animationFrameRef.current = requestAnimationFrame(updateAudioLevel);\n    };\n    \n    updateAudioLevel();\n  };\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      mediaRecorderRef.current = new MediaRecorder(stream);\n      audioChunksRef.current = [];\n\n      // Inizializza l'analizzatore audio quando inizia la registrazione\n      setupAudioAnalyser(stream);\n\n      mediaRecorderRef.current.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n\n      mediaRecorderRef.current.onstop = async () => {\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });\n        await sendAudioToBackend(audioBlob);\n        setAudioLevel(0); // Resetta il livello audio quando si ferma\n      };\n\n      mediaRecorderRef.current.start();\n      setIsRecording(true);\n      setStatus('Recording...');\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n      setStatus('Error: ' + error.message);\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());\n      setIsRecording(false);\n      setStatus('Processing audio...');\n    }\n  };\n\n  const setupResponseAudioAnalyser = (audioElement) => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    const analyser = audioCtx.createAnalyser();\n    const source = audioCtx.createMediaElementSource(audioElement);\n    \n    analyser.fftSize = 32;\n    source.connect(analyser);\n    analyser.connect(audioCtx.destination);\n    analyserRef.current = analyser;\n    \n    const updateAudioLevel = () => {\n      const dataArray = new Uint8Array(analyser.frequencyBinCount);\n      analyser.getByteFrequencyData(dataArray);\n      \n      const weights = dataArray.map((value, i) => value * (i + 1));\n      const weightedAverage = weights.reduce((a, b) => a + b, 0) / weights.length;\n      \n      setAudioLevel(weightedAverage / 128);\n      if (audioElement.paused) {\n        setAudioLevel(0);\n        setIsAssistantSpeaking(false);\n        return;\n      }\n      animationFrameRef.current = requestAnimationFrame(updateAudioLevel);\n    };\n    \n    audioElement.addEventListener('play', () => {\n      setIsAssistantSpeaking(true);\n      updateAudioLevel();\n    });\n    \n    audioElement.addEventListener('pause', () => {\n      setIsAssistantSpeaking(false);\n      setAudioLevel(0);\n    });\n    \n    audioElement.addEventListener('ended', () => {\n      setIsAssistantSpeaking(false);\n      setAudioLevel(0);\n    });\n  };\n\n  const setupAssistantAudioAnalyser = (audioData) => {\n    try {\n      const audio = new Audio(audioData);\n      audioRef.current = audio;\n      \n      // Connetti l'analizzatore audio\n      if (audioAnalyzer.current) {\n        audioAnalyzer.current.connectSource(audio);\n      }\n\n      audio.addEventListener('play', () => {\n        setIsAssistantSpeaking(true);\n        console.log('Audio started playing');\n      });\n\n      audio.addEventListener('pause', () => {\n        setIsAssistantSpeaking(false);\n        setAudioLevel(0);\n        console.log('Audio paused');\n      });\n\n      audio.addEventListener('ended', () => {\n        setIsAssistantSpeaking(false);\n        setAudioLevel(0);\n        console.log('Audio ended');\n      });\n\n      return audio;\n    } catch (error) {\n      console.error('Error setting up audio:', error);\n      return null;\n    }\n  };\n\n  const sendAudioToBackend = async (audioBlob) => {\n    const formData = new FormData();\n    formData.append('audio', audioBlob, 'recording.wav');\n\n    try {\n      const response = await fetch(ENDPOINTS.AUDIO_UPLOAD, {\n        method: 'POST',\n        body: formData\n      });\n\n      if (!response.ok) throw new Error('Network response was not ok');\n      \n      const data = await response.json();\n      console.log('Received response:', data); // Debug log\n      \n      setStatus(data.text || 'Audio processed');\n      if (data.text) setCommand(data.text);\n      \n      // Gestione della risposta audio\n      if (data.audio_response) {\n        const audioData = `data:audio/wav;base64,${data.audio_response}`;\n        console.log('Playing audio response'); // Debug log\n        const audio = setupAssistantAudioAnalyser(audioData);\n        await audio.play().catch(e => console.error('Error playing audio:', e));\n      } else {\n        console.log('No audio response received'); // Debug log\n      }\n    } catch (error) {\n      setStatus('Error: ' + error.message);\n      console.error('Error sending audio:', error);\n    }\n  };\n\n  const handleMic = () => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  };\n\n  const handleKeyPress = (e) => {\n    if (e.key === 'Enter' && command.trim()) {\n      handleSend();\n    }\n  };\n\n  useEffect(() => {\n    // Inizializza AudioAnalyzer una sola volta\n    audioAnalyzer.current = new AudioAnalyzer();\n    \n    const updateLevel = () => {\n      if (audioRef.current && !audioRef.current.paused) {\n        setAudioLevel(audioAnalyzer.current.getLevel());\n      }\n      animationFrameRef.current = requestAnimationFrame(updateLevel);\n    };\n    updateLevel();\n    \n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    };\n  }, []);\n\n// Rimuovi o commenta il secondo useEffect duplicato che inizializza AudioAnalyzer:\n// useEffect(() => {\n//   audioAnalyzer.current = new AudioAnalyzer();\n//   const updateLevel = () => {\n//     if (audioRef.current && !audioRef.current.paused) {\n//       const level = audioAnalyzer.current.getLevel();\n//       setAudioLevel(level);\n//     }\n//     animationFrameRef.current = requestAnimationFrame(updateLevel);\n//   };\n//   updateLevel();\n//   return () => {\n//     if (animationFrameRef.current) {\n//       cancelAnimationFrame(animationFrameRef.current);\n//     }\n//   };\n// }, []);\n\n  return (\n    <div className=\"App\">\n      <div className=\"content-container\">\n        <div className=\"visualizer-container\">\n          <BezierDiamond \n            audioLevel={audioLevel} \n            isActive={isAssistantSpeaking}\n          />\n        </div>\n        <div className=\"controls-container\">\n          <input\n            type=\"text\"\n            id=\"command-input\"\n            value={command}\n            onChange={(e) => setCommand(e.target.value)}\n            onKeyPress={handleKeyPress}\n            placeholder=\"Enter a command\"\n          />\n          <button \n            id=\"mic-btn\" \n            onClick={handleMic} \n            title=\"Record voice command\"\n            className={isRecording ? 'recording' : ''}\n          >\n            <i className=\"fas fa-microphone\"></i>\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}